---
title: "JavaScript Event Loop"
publishedAt: "2025-02-01"
summary: ""
language: "en"
tags: []
---

Hello. I'm Jindo, a frontend developer.

When I first encountered JavaScript, there was a concept that was difficult to grasp.

JavaScript is a single-threaded language, and it can prevent blocking issues from long-running tasks by processing them with asynchronous functions.

I had a question: if JavaScript is single-threaded, where do asynchronous operations happen, and how are they managed?

One of the answers to that question is this topic: the **Event Loop**.

## Event Loop Components

Before understanding how the Event Loop works, it's necessary to understand each component it manages. ([Image Source](https://www.lydiahallie.com/blog/event-loop))

![image.png](https://velog.velcdn.com/images/yeojinseuk/post/8f235aec-0b3c-433c-b154-07219f9a5b09/image.png)

### Call Stack

The Call Stack manages the execution context of a JavaScript program.
When a function is executed, it's pushed onto the Call Stack, creating an execution context.

This is where common JavaScript functions like `console.log()` are pushed and popped.

### Web APIs

These are APIs provided by the browser, used to interact with features utilized by the browser. Some provide asynchronous operations in the background, and these asynchronous operations run within the browser itself.

Today, we'll take a closer look at the asynchronous Web APIs necessary for explaining the Event Loop.

Asynchronous functions in Web APIs primarily come in two types.

### 1. Web APIs that execute callbacks

A prime example is the `setTimeout` function.

```javascript
setTimeout(() => {
  console.log('2000ms');
},100);
```

Taking the `setTimeout` function as an example, after the browser asynchronously manages the 100ms duration, it will move the callback to be executed by the JavaScript engine once 100ms has passed.

For it to be executed by the JavaScript engine, it needs to enter the Call Stack. However, if asynchronous functions continuously enter the Call Stack immediately, conflicts would arise.

To prevent this, there's something called the Task Queue, and the callback provided to `setTimeout` is configured to move to the Task Queue after 100ms.

I will explain the Task Queue later.

### 2. Web APIs that return Promises

Most modern Web APIs provide a mechanism that returns a Promise.
A prime example is the `fetch` API.

```javascript
fetch("...")
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

In the case of this Web API, after the function executes in the browser, it moves `then`, `catch`, etc., to be executed by the JavaScript engine.

Promises are structured to move to the Microtask Queue, which is slightly different from callback-based Web APIs.

### Task Queue

This is a queue where Web API callbacks and event handlers are stored.
(It's also sometimes called the **Callback Queue** because Web API callbacks are placed here.)
Its purpose is that when the Call Stack is empty, the Event Loop moves tasks from the Task Queue to the Call Stack for execution.
(`setTimeout`, `setInterval`, etc.)

### Microtask Queue

This is a queue where callbacks for `Promise Callback`, `async await`, `MutationObserver`, etc., are stored.
The Microtask Queue is the highest priority queue; if the Call Stack is empty, the Event Loop consumes tasks from it before the Task Queue. (**Executes even before rendering**)
(`Promise.then`, `catch`, `finally`, `fetch`, etc.)

## Event Loop Operation

Now, let's return to the main topic and examine the Event Loop.

### Basic Operation

The Event Loop's role is to move tasks from the queues described above to the Call Stack. (Function execution is handled by the JavaScript engine and the browser.)

The Event Loop continuously runs a loop, checking if the Call Stack is empty.

If the Call Stack becomes empty during the loop, it determines that there are no ongoing tasks and moves the oldest executable function from the Microtask Queue or Task Queue (Microtask Queue has higher priority) to the Call Stack.

The Event Loop continuously repeats the process described above.

The code below is a simplified, informal representation of the process written in JavaScript to aid understanding.

```javascript
while(true){
  if(!콜스택이_비어있는가){
    return;
  }

  if(마이크로_태스크큐_대기중인_작업이_있는가){
    콜스택에_마이크로_태스크큐_작업_넣기();
    return;
  }

  render()

  if(태스크큐_대기중인_작업이_있는가){
    콜스택에_태스크큐_작업_넣기();
    return;
  }
}
```

### How the Task Queue Operates

We mentioned that callback-based asynchronous Web APIs are managed in the Task Queue.
Let's examine this process in more detail using `setTimeout` code.

```javascript
setTimeout(() => {
  console.log('2000ms');
},2000);

setTimeout(() => {
  console.log('100ms');
},100);

console.log('end');
```

According to the Event Loop explanation above, the following process will occur:

1.  The `setTimeout` function is called and pushed onto the Call Stack.
2.  The callback function is passed to the Timer Web API, and the browser counts 2000ms.
3.  The `setTimeout` function is removed from the Call Stack.
4.  The `setTimeout` function is called and pushed onto the Call Stack.
5.  The callback function is passed to the Timer Web API, and the browser counts 100ms.
6.  The `setTimeout` function is removed from the Call Stack.
7.  `console.log('end')` is pushed onto the Call Stack.
8.  `console.log('end')` is removed from the Call Stack.
9.  The 100ms callback moves to the Call Stack.
10. `console.log('100ms');` is pushed onto the Call Stack.
11. `console.log('100ms');` is removed from the Call Stack.
12. The 2000ms callback is removed from the Call Stack.
13. The 100ms callback moves to the Call Stack.
14. `console.log('2000ms');` is pushed onto the Call Stack.
15. `console.log('2000ms');` is removed from the Call Stack.
16. The 2000ms callback is removed from the Call Stack.

Here's a good GIF that illustrates this process (

[Source](https://www.lydiahallie.com/blog/event-loop)

)

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/f554b351-24e3-413a-853b-87259d5cfaa7/image.gif)

### How the Microtask Queue Operates

The Microtask Queue operates in the same way as the Task Queue.
The difference, as explained above, is that the Event Loop processes it with the highest priority.

Again, here's a good GIF that illustrates this process (

[Source](https://www.lydiahallie.com/blog/event-loop)

)

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/df1eb250-3412-4bd9-8049-8e574b0bd8d2/image.gif)

> It's important to note that since these tasks have higher priority than rendering, if too many tasks accumulate in the Microtask Queue, rendering itself might freeze.

## Examining with React

Let's examine the Event Loop's operation through React code, which is familiar to React developers.

### Problematic Code

The following code consists of an x-axis scrollable list and a button that adds an item to the list and scrolls to the newly added item.

```javascript
const [listData, setListData] = React.useState(data);
  const containerRef = React.useRef<HTMLDivElement>(null);

  const handleAddItem = () => {
    setListData((prev) => [...prev, item]);

    containerRef.current?.scrollTo({
   	  left: ref.current?.scrollWidth,
      behavior: "smooth",
    });
  };


  return (
      <>
        <div
          ref={containerRef}
          style={{
            display: "flex",
            flexDirection: "row",
            gap: 10,
            width: "100%",
            overflowX: "scroll",
          }}
        >
          {listData.map((item) => (
            <div
              key={item}
              style={{
                backgroundColor: "tomato",
                width: 300,
                height: 300,
              }}
            >
              <div style={{ width: 300 }}>{item}</div>
            </div>
          ))}
        </div>

        <button
          type="button"
          onClick={handleAddItem}
        >
         +
        </button>
      </>
  );
```

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/a9c98de2-aea1-4d51-8eb3-f399a0406268/image.gif)

This code does not work as intended.
Why doesn't it work?

Let's understand this through the Event Loop's operation we examined earlier.

1.  The button is clicked, and the `onClick` event handler function is added to the Call Stack.
2.  `handleAddItem()` is added to the Call Stack.
3.  `setListData()` is added to the Call Stack.
4.  The React `setState` callback is added to the batch processing queue (processed in the Microtask Queue).
5.  `setListData()` is removed from the Call Stack.
6.  The `scrollTo()` function is added to the Call Stack.
7.  `scrollTo()` is called (but the state has not yet changed).
8.  The `scrollTo()` function is removed from the Call Stack.
9.  `handleAddItem()` is removed from the Call Stack.
10. The `onClick` event handler function is removed from the Call Stack.
11. The React batch update function executes from the Microtask Queue.
12. Rendering.

Going through the Event Loop process step by step, we can see what the problem is.

This is because React handles batch updates, performing state updates in the Microtask Queue.

### Let's Use the Task Queue

We mentioned that in the Event Loop, the Microtask Queue is always executed first.
To make it work as intended, let's leverage the operating principles of the Event Loop.

```javascript
...
  const handleAddItem = () => {
    setListData((prev) => [...prev, item]);

    setTimeout(() => {
      ref.current?.scrollTo({
        left: ref.current?.scrollWidth,
        behavior: "smooth",
      });
    }, 0);
  };

...
```

We placed the `scrollTo` function inside a `setTimeout` callback.

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/e86ff142-2b58-493f-90c8-dd06684cf61b/image.gif)

Great! It works perfectly as intended.

Let's examine the Event Loop's operation process again.

1.  The button is clicked, and the `onClick` event handler function is added to the Call Stack.
2.  `handleAddItem()` is added to the Call Stack.
3.  `setListData()` is added to the Call Stack.
4.  The React `setState` callback is added to the batch processing queue (processed in the Microtask Queue).
5.  `setListData()` is removed from the Call Stack.
6.  The `setTimeout` function is added to the Call Stack.
7.  The callback function is passed to the Timer Web API, the browser counts 0ms, and then places it in the Task Queue.
8.  The `setTimeout` function is removed from the Call Stack.
9.  `handleAddItem()` is removed from the Call Stack.
10. The `onClick` event handler function is removed from the Call Stack.
11. The React batch update function executes from the Microtask Queue.
12. Rendering.
13. The `setTimeout` Callback moves from the Task Queue to the Call Stack.
14. The `scrollTo()` function is added to the Call Stack.
15. `scrollTo()` is called.
16. The `scrollTo()` function is removed from the Call Stack.
17. The `setTimeout` Callback is removed from the Call Stack.

By examining the Event Loop's operation up to this point, it became clear why it works.

## Summary

-   JavaScript's asynchronous processing is managed by the browser's Event Loop.
-   Web APIs provide both callback-based asynchronous functions and Promise-based asynchronous functions.
-   Callback-based asynchronous functions accumulate in the Task Queue, while Promise-based asynchronous functions accumulate in the Microtask Queue.
-   If the Call Stack is empty, the Event Loop moves tasks from the Microtask Queue or Task Queue to the Call Stack, managing asynchronous operations.
-   The Event Loop literally loops infinitely, repeating this operation.

## Conclusion

Up to this point, we have thoroughly examined the operation of the JavaScript Event Loop.
If there are any inaccuracies, please feel free to provide feedback in the comments.

Thank you.

# References

[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop)
[Lydia Hallie's Event Loop Explanation](https://www.lydiahallie.com/blog/event-loop)
[Inpa's Event Loop Explanation](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%B4%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
[React Batch Update](https://react.dev/learn/queueing-a-series-of-state-updates)