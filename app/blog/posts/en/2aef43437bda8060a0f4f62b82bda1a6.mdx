---
title: "JavaScript Event Loop"
publishedAt: "2025-02-01"
summary: ""
language: "en"
tags: []
---

Hello. I'm Jindo, a frontend developer.

When I first encountered JavaScript, there was a concept that I found difficult to grasp.

JavaScript is a single-threaded language, and it can prevent blocking issues from long-running tasks by processing them with asynchronous functions.

I had a question: if JavaScript is single-threaded, where do asynchronous operations happen, and how are they managed?

One of the answers to that question is this topic: the **Event Loop**.

## Event Loop Components

Before understanding how the Event Loop works, it's necessary to understand each component it manages. ([Image source](https://www.lydiahallie.com/blog/event-loop))

![image.png](https://velog.velcdn.com/images/yeojinseuk/post/8f235aec-0b3c-433c-b154-07219f9a5b09/image.png)

### Call Stack

The Call Stack manages the execution context of a JavaScript program.
When a function is executed, it's pushed onto the Call Stack, creating an execution context.

This is where common JavaScript functions like `console.log()` are stacked and consumed.

### Web APIs

These are APIs provided by the browser, used to interact with features utilized by the browser. Some provide asynchronous operations in the background, and these asynchronous operations are executed by the browser itself.

Today, we'll take a closer look at the asynchronous Web APIs necessary for explaining the Event Loop.

Asynchronous Web API functions primarily come in two types.

### 1. Web APIs that execute callbacks

A prime example is the `setTimeout` function.

```javascript
setTimeout(() => {
  console.log('2000ms');
},100);
```

Taking `setTimeout` as an example, the browser will asynchronously manage the 100ms duration, and after 100ms, it will move the callback to be executed by the JavaScript engine.

For execution by the JavaScript engine, it needs to enter the Call Stack. However, if asynchronous functions were to continuously enter the Call Stack immediately, conflicts would arise.

To prevent this, there's a mechanism called the Task Queue, and the callback provided to `setTimeout` moves to the Task Queue after 100ms.

I will explain the Task Queue later.

### 2. Web APIs that return a Promise

Most modern Web APIs provide a mechanism that returns a Promise.
A prime example is the `fetch` API.

```javascript
fetch("...")
  .then(data => console.log(data))
  .catch(error => console.error(error));
```

In the case of this Web API, after the function is executed in the browser, it moves `then`, `catch`, etc., to be executed by the JavaScript engine.

Promises are structured to move to the Microtask Queue, which is slightly different from callback-based Web APIs.

### Task Queue

This is a queue where Web API callbacks and event handlers are stored.
(It's also referred to as the **Callback Queue** because Web API callbacks are placed there.)
Its purpose is that when the Call Stack is empty, the Event Loop moves tasks from the Task Queue to the Call Stack for execution.
(e.g., `setTimeout`, `setInterval`)

### Microtask Queue

This is a queue where callbacks for Promise, `async`/`await`, `MutationObserver`, etc., are stored.
The Microtask Queue is the highest priority queue; the Event Loop consumes tasks from it before the Task Queue when the Call Stack is empty. (**Executed even before rendering**)
(e.g., `Promise.then`, `catch`, `finally`, `fetch`)

## Event Loop Operation Process

Now, let's return to the main topic and examine the Event Loop.

### Basic Operation

The Event Loop's role is to move tasks from the queues described above to the Call Stack. (Function execution is handled by the JavaScript engine and the browser.)

The Event Loop continuously runs a loop, checking if the Call Stack is empty.

If the Call Stack becomes empty during the loop, it assumes there are no ongoing tasks and moves the oldest executable function from the Microtask Queue or Task Queue (Microtask Queue has higher priority) to the Call Stack.

The Event Loop continuously repeats the process described above.

The code below is a simplified, 'hacky' representation of the process using JavaScript to aid understanding.

```javascript
while(true){
  if(!콜스택이_비어있는가){
    return;
  }

  if(마이크로_태스크큐_대기중인_작업이_있는가){
    콜스택에_마이크로_태스크큐_작업_넣기();
    return;
  }

  render()

  if(태스크큐_대기중인_작업이_있는가){
    콜스택에_태스크큐_작업_넣기();
    return;
  }
}
```

### Task Queue Operation Process

We mentioned that callback-based asynchronous Web APIs are managed in the Task Queue.
Let's examine this process in more detail using `setTimeout` code.

```javascript
setTimeout(() => {
  console.log('2000ms');
},2000);

setTimeout(() => {
  console.log('100ms');
},100);

console.log('end');
```

According to the Event Loop explanation above, the following process will occur:

1.  The `setTimeout` function is called and pushed onto the Call Stack.
2.  The callback function is passed to the Timer Web API, and the browser counts 2000ms.
3.  The `setTimeout` function is removed from the Call Stack.
4.  The `setTimeout` function is called and pushed onto the Call Stack.
5.  The callback function is passed to the Timer Web API, and the browser counts 100ms.
6.  The `setTimeout` function is removed from the Call Stack.
7.  `console.log('end')` is pushed onto the Call Stack.
8.  `console.log('end')` is removed from the Call Stack.
9.  The 100ms callback moves to the Call Stack.
10. `console.log('100ms');` is pushed onto the Call Stack.
11. `console.log('100ms');` is removed from the Call Stack.
12. The 2000ms callback is removed from the Call Stack.
13. The 100ms callback moves to the Call Stack.
14. `console.log('2000ms');` is pushed onto the Call Stack.
15. `console.log('2000ms');` is removed from the Call Stack.
16. The 2000ms callback is removed from the Call Stack.

Here's a good GIF that illustrates this process (

[Source](https://www.lydiahallie.com/blog/event-loop)

)

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/f554b351-24e3-413a-853b-87259d5cfaa7/image.gif)

### Microtask Queue Operation Process

The Microtask Queue operates similarly to the Task Queue.
The difference, as explained above, is that the Event Loop processes it with the highest priority.

Again, here's a good GIF that illustrates this process (

[Source](https://www.lydiahallie.com/blog/event-loop)

)

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/df1eb250-3412-4bd9-8049-8e574b0bd8d2/image.gif)

> It's important to note that since these tasks have higher priority than rendering, if too many tasks accumulate in the Microtask Queue, rendering itself can be blocked.

## Examining with React

Let's examine the Event Loop's operation through React code, which is familiar to React developers.

### Problematic Code

The following code consists of an x-axis scrollable list and a button that adds an item to the list and scrolls to the newly added item.

```javascript
const [listData, setListData] = React.useState(data);
  const containerRef = React.useRef<HTMLDivElement>(null);

  const handleAddItem = () => {
    setListData((prev) => [...prev, item]);

    containerRef.current?.scrollTo({
   	  left: ref.current?.scrollWidth,
      behavior: "smooth",
    });
  };


  return (
      <>
        <div
          ref={containerRef}
          style={{
            display: "flex",
            flexDirection: "row",
            gap: 10,
            width: "100%",
            overflowX: "scroll",
          }}
        >
          {listData.map((item) => (
            <div
              key={item}
              style={{
                backgroundColor: "tomato",
                width: 300,
                height: 300,
              }}
            >
              <div style={{ width: 300 }}>{item}</div>
            </div>
          ))}
        </div>

        <button
          type="button"
          onClick={handleAddItem}
        >
         +
        </button>
      </>
  );
```

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/a9c98de2-aea1-4d51-8eb3-f399a0406268/image.gif)

This code does not work as intended.
Why doesn't it work?

Let's understand this through the Event Loop's operation process we examined earlier.

1.  The button is clicked, and the `onClick` event handler function is added to the Call Stack.
2.  `handleAddItem()` is added to the Call Stack.
3.  `setListData()` is added to the Call Stack.
4.  The React `setState` callback is added to the batch processing queue (processed in the Microtask Queue).
5.  `setListData()` is removed from the Call Stack.
6.  The `scrollTo()` function is added to the Call Stack.
7.  `scrollTo()` is called (but the state has not yet changed).
8.  The `scrollTo()` function is removed from the Call Stack.
9.  `handleAddItem()` is removed from the Call Stack.
10. The `onClick` event handler function is removed from the Call Stack.
11. The React batch update function is executed from the Microtask Queue.
12. Rendering occurs.

Going through the Event Loop process step by step, it's clear what the problem is.

This is because React performs batch updates, and the state update happens in the Microtask Queue.

### Let's use the Task Queue

We mentioned that the Microtask Queue is always executed first in the Event Loop.
To make it work as intended, let's utilize the Event Loop's operating principles.

```javascript
...
  const handleAddItem = () => {
    setListData((prev) => [...prev, item]);

    setTimeout(() => {
      ref.current?.scrollTo({
        left: ref.current?.scrollWidth,
        behavior: "smooth",
      });
    }, 0);
  };

...
```

We placed the `scrollTo` function inside a `setTimeout` callback.

![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/e86ff142-2b58-493f-90c8-dd06684cf61b/image.gif)

Great! It works perfectly as intended.

Let's examine the Event Loop's operation process again.

1.  The button is clicked, and the `onClick` event handler function is added to the Call Stack.
2.  `handleAddItem()` is added to the Call Stack.
3.  `setListData()` is added to the Call Stack.
4.  The React `setState` callback is added to the batch processing queue (processed in the Microtask Queue).
5.  `setListData()` is removed from the Call Stack.
6.  The `setTimeout` function is added to the Call Stack.
7.  The callback function is passed to the Timer Web API, the browser counts 0ms, and then places it into the Task Queue.
8.  The `setTimeout` function is removed from the Call Stack.
9.  `handleAddItem()` is removed from the Call Stack.
10. The `onClick` event handler function is removed from the Call Stack.
11. The React batch update function is executed from the Microtask Queue.
12. Rendering occurs.
13. The `setTimeout` callback moves from the Task Queue to the Call Stack.
14. The `scrollTo()` function is added to the Call Stack.
15. `scrollTo()` is called.
16. The `scrollTo()` function is removed from the Call Stack.
17. The `setTimeout` callback is removed from the Call Stack.

Through this explanation of the Event Loop's operation, it became clear why it works.

## Summary

-   JavaScript's asynchronous processing is managed by the browser's Event Loop.
-   Web APIs provide both callback-based asynchronous functions and Promise-based asynchronous functions.
-   Callback-based asynchronous functions accumulate in the Task Queue, while Promise-based asynchronous functions accumulate in the Microtask Queue.
-   When the Call Stack is empty, the Event Loop moves tasks from the Microtask Queue or Task Queue to the Call Stack, managing asynchronous operations.
-   The Event Loop literally loops infinitely, repeating this operation.

## Conclusion

Up to this point, we have thoroughly examined the operation of the JavaScript Event Loop.
If there are any inaccuracies, please feel free to provide feedback in the comments.

Thank you.

# References

[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop)
[Lydia Hallie's Event Loop Explanation](https://www.lydiahallie.com/blog/event-loop)
[Inpa's Event Loop Explanation](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)
[React Batch Update](https://react.dev/learn/queueing-a-series-of-state-updates)