---
title: "event loop"
publishedAt: "2024-02-03"
summary: ""
language: "ko"
tags: []
---


자바스크립트는 싱글 스레드 언어이며, 비동기 함수로 작업을 처리하여 오래걸리는 작업의 블로킹 현상을 막을 수 있습니다.


자바스크립트는 싱글 스레드인데 비동기 작업은 어디서 해주며 어떻게 관리를 해주는 것일까라는 의문이 있었습니다.


그 정답 중 하나는 이번 주제인 **이벤트 루프**입니다.


## 이벤트 루프 구성 요소


이벤트 루프 동작에 대해서 이해하기 앞서서 이벤트 루프가 관리하는 각각의 요소에 대해서 이해할 필요가 있습니다. ([이미지 출처](https://www.lydiahallie.com/blog/event-loop))


![image.png](https://velog.velcdn.com/images/yeojinseuk/post/8f235aec-0b3c-433c-b154-07219f9a5b09/image.png)


### Call Stack


Call Stack은 자바스크립트 프로그램 실행 context를 관리합니다.
어떤 함수가 실행되면 Call Stack에 하나씩 쌓이며 실행 context가 만들어집니다.


console.log() 등 일반적인 자바스크립트 함수가 쌓이고 소모되는 곳입니다.


### Web APIs


브라우저에서 활용하는 기능과 상호 작용하는 데 사용되는 브라우저에서 제공해주는 API들 입니다. 일부는 백그라운드에서 비동기 작업을 제공해주고 비동기 작업은 브라우저 자체에서 실행됩니다.


오늘은 이벤트 루프 설명에 필요한 비동기 Web APIs를 좀 더 자세히 살펴보겠습니다.


Web APIs 비동기 함수들은 크게 두가지 방식이 존재합니다.


### 1. call back을 실행하는 Web API


대표적으로 setTimeout 함수가 있습니다.


```javascript
setTimeout(() => {
  console.log('2000ms');
},100);
```


setTimeout함수를 예로 보면 100ms 시간을 브라우저에서 비동기로 관리한 후 100ms 지나면 call back을 자바스크립트 엔진에서 실행시키도록 옮겨줄 것입니다.


자바스크립트 엔진에서 실행시키려면 Call Stack에 들어가야 되는데, 이 때 비동기 함수들이 Call Stack에 바로바로 계속 들어가면 충돌이 생길 것입니다.


이를 방지하기 위해 Task Queue라는 것이 있고 setTimeout에 넣어준 callback은 100ms가 지나면 Task Queue로 이동하는 방식으로 구성됩니다.


Task Queue는 뒤에서 설명드리도록 하겠습니다.


### 2. Promise를 반환하는 Web API


최신 Web API들은 대부분 Promise를 반환하는 방식을 제공해줍니다.
대표적으로는 fetch API가 있습니다.


```javascript
fetch("...")
  .then(data => console.log(data))
  .catch(error => console.error(error));
```


해당 Web API의 경우는 브라우저에서 함수가 실행된 후 then, catch 등을 자바스크립트 엔진에서 실행될 수 있도록 옮겨줍니다.


Promise는 callback 방식의 Web API와는 조금 다르게 Microtask Queue로 이동하는 방식으로 구성됩니다.


### Task Queue


Web API 콜백 및 이벤트 핸들러가 보관되는 Queue입니다.
(Web API의 callback을 넣어놓기에 **Callback Queue** 라고 불리기도 함)
Call Stack이 비워지면 이벤트 루프가 Task Queue에 있는 Task를 Call Stack으로 이동하여 실행하도록 하는 목적입니다.
(setTimeout, setInterval 등)


### Microtask Queue


Promise Callback, async await, MutationObserver 등의 callback이 보관되는 Queue입니다.
마이크로 태스크큐는 이벤트 루프가 Call Stack이 비어져있으면 Task Queue 보다 먼저 소모하는 우선순위가 가장 높은 Queue입니다. (**렌더링보다도 먼저 실행**)
(Promise.then, catch, finally, fetch 등)


## 이벤트 루프 동작 과정


이제 본론으로 돌아와서 이벤트 루프에 대해서 살펴보겠습니다.


### 기본 동작


이벤트 루프는 위에서 설명한 Queue들의 작업을 CallStack으로 옮겨주는 역할을 합니다. (함수의 실행 처리는 자바스크립트 엔진, 브라우저가 처리)


이벤트 루프는 Call Stack이 비어있는지 확인하는 루프를 계속 돌고 있습니다.


루프중 CallStack이 비게 되면 현재 진행중인 작업이 없다 판단하고 Microtask Queue나 Task Queue(Microtask Queue가 우선순위가 높음)에서 대기중인 작업 중 실행가능한 가장 오래된 함수를 Call Stack으로 옮겨줍니다.


이벤트 루프는 위의 과정을 지속적으로 반복합니다.


아래 코드는 이해를 돕기 위해 javascript를 활용하여 야매로 다음 과정을 작성해보았습니다.


```javascript
while(true){
  if(!콜스택이_비어있는가){
    return;
  }

  if(마이크로_태스크큐_대기중인_작업이_있는가){
    콜스택에_마이크로_태스크큐_작업_넣기();
    return;
  }

  render()

  if(태스크큐_대기중인_작업이_있는가){
    콜스택에_태스크큐_작업_넣기();
    return;
  }
}
```


### Task Queue가 동작하는 과정


Callback 기반의 비동기 Web API는 Task Queue에서 관리한다고 하였습니다.
setTimeout 코드를 통해 해당 과정을 조금 더 자세히 살펴보도록 하겠습니다.


```javascript
setTimeout(() => {
  console.log('2000ms');
},2000);

setTimeout(() => {
  console.log('100ms');
},100);

console.log('end');
```


위에서 설명한 Event loop에 따르면 다음과 같은 과정을 진행할 것입니다.

1. setTimeout 함수가 호출되어 Call Stack에 쌓임
2. 콜백 함수를 Timer Web API에 전달하고, 브라우저에서는 2000ms를 셈함
3. setTimeout 함수 Call Stack에서 제거
4. setTimeout 함수가 호출되어 Call Stack에 쌓임
5. 콜백 함수를 Timer Web API에 전달하고,브라우저에서는 100ms 셈함
6. setTimeout 함수 Call Stack에서 제거
7. console.log('end')가 Call Stack에 쌓임
8. console.log('end') Call Stack에서 제거
9. 100ms callback Call Stack으로 이동
10. console.log('100ms'); Call Stack에 쌓임
11. Call Stack에서 console.log('100ms'); 제거
12. Call Stack에서 2000ms callback 제거
13. 100ms callback Call Stack으로 이동
14. console.log('2000ms'); Call Stack에 쌓임
15. Call Stack에서 console.log('2000ms'); 제거
16. Call Stack에서 2000ms callback 제거

해당 과정을 설명하는 좋은 gif가 있어서 소개드립니다(


[출처](https://www.lydiahallie.com/blog/event-loop)


)


![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/f554b351-24e3-413a-853b-87259d5cfaa7/image.gif)


### MicroTask Queue가 동작하는 과정


MicroTask Queue도 Task Queue와 동일하게 동작을 하게 됩니다.
다른 점은 위에서 설명했던 것처럼 이벤트 루프가 가장 높은 우선순위로 처리를 하게 됩니다.

이번에도 해당 과정을 설명하는 좋은 gif가 있어서 소개드립니다 (


[출처](https://www.lydiahallie.com/blog/event-loop)


)


![image.gif](https://velog.velcdn.com/images/yeojinseuk/post/df1eb250-3412-4bd9-8049-8e574b0bd8d2/image.gif)

> 주의해야할 점은 렌더링보다 우선순위에 있는 작업이라 microtask Queue에 작업 자체가 너무 많이 쌓이게 되면 렌더링 자체가 멈추는 현상이 생길 수 있습니다.

## 정리

- 자바스크립트의 비동기처리는 브라우저의 이벤트 루프가 관리함
- Web APIs에는 Callback 기반의 비동기 함수와 Promise 기반의 비동기 함수를 제공함
- Callback 기반의 비동기 함수는 Task Queue에서 쌓이고 Promise 기반의 비동기 함수는 Microtask Queue에 쌓임
- 이벤트 루프는 Call Stack이 비어있으면 Microtask Queue or Task Queue를 Call Stack으로 옮겨주며 비동기 작업을 관리 함
- 이벤트 루프는 말 그대로 무한으로 루프하며 해당 동작을 반복 함

## 마무리


여기까지 자바스크립트 이벤트 루프 동작에 대해서 자세히 살펴보았습니다.
틀린 부분이 있으면 댓글로 자유롭게 피드백 부탁드리겠습니다.


감사합니다.


# References


[MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop)


[lydiahallie님의 Event Loop 설명](https://www.lydiahallie.com/blog/event-loop)


[인파님의 Event Loop 설명](https://inpa.tistory.com/entry/%F0%9F%94%84-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B5%AC%EC%A1%B0-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC)


[React Batch Update](https://react.dev/learn/queueing-a-series-of-state-updates)

